package org.firstinspires.ftc.teamcode.TeleOp;import android.os.Build;import androidx.annotation.RequiresApi;import com.qualcomm.robotcore.eventloop.opmode.OpMode;import com.qualcomm.robotcore.eventloop.opmode.TeleOp;import com.qualcomm.robotcore.util.ElapsedTime;import org.firstinspires.ftc.teamcode.HardwareClasses.Controller;import org.firstinspires.ftc.teamcode.HardwareClasses.Intake;import org.firstinspires.ftc.teamcode.HardwareClasses.Robot;import org.firstinspires.ftc.teamcode.HardwareClasses.Sensors;import org.firstinspires.ftc.teamcode.HardwareClasses.Sensors.Alliance;import org.firstinspires.ftc.teamcode.HardwareClasses.Shooter;import org.firstinspires.ftc.teamcode.HardwareClasses.Wobble;import org.firstinspires.ftc.utilities.Utils;//import org.firstinspires.ftc.teamcode.HardwareClasses.Shooter;@TeleOp(name = "RED Tele Op", group = "TeleOp")public class RedTeleOp extends OpMode {		private boolean realMatch = true, autoAim = true;	private int gyroOffset = 0;	private String offsetTelemetry = "forward";		private final ElapsedTime mainTime = new ElapsedTime();	private Controller driver, operator;				@Override	public void init() {				Utils.setHardwareMap(hardwareMap);		Robot.init(); Sensors.init(Alliance.RED); Intake.init(); Shooter.init(); Wobble.init();				driver = new Controller(gamepad1); operator = new Controller(gamepad2);		mainTime.reset();				Sensors.frontCamera.setPipeline(Sensors.frontCamera.blueAimPipeline);		Sensors.frontCamera.startVision(320, 240);	}				@RequiresApi(api = Build.VERSION_CODES.N)	@Override	public void init_loop() {		Sensors.update();		driver.update(); operator.update();				Robot.setPower(0,0, driver.leftStick.X(), driver.RT.range(.3, .6));		Shooter.lockFeeder(); Shooter.resetFeeder(); Shooter.shooterOff();		Intake.intakeOff();				if(driver.up.press()) { gyroOffset = 0; offsetTelemetry = "forward"; }		if(driver.left.press()) { gyroOffset = -90; offsetTelemetry = "left"; }		if(driver.right.press()) { gyroOffset = 90; offsetTelemetry = "right"; }		if(driver.down.press()) { gyroOffset = 180; offsetTelemetry = "backward"; }				Shooter.setTurretAngle(40);				realMatch = !driver.share.toggle();		autoAim = !driver.triangle.toggle();				initTelemetry();	}				@Override	public void start() {		Sensors.update();		Robot.resetGyro(gyroOffset);		Wobble.newState(Wobble.GripperState.HALF); Wobble.newState(Wobble.ArmState.FOLD);		mainTime.reset();	}				@RequiresApi(api = Build.VERSION_CODES.N)	@Override	public void loop() {		Sensors.update(); driver.update(); operator.update();		driver.rightStick.setShift(Sensors.gyro.modAngle());				//movement controls		Robot.driveState(driver.rightStick.shiftedY(), driver.rightStick.shiftedX(), driver.leftStick.X(), driver.RT.range(.5, 1));		Robot.cardinalState(driver.up.press(), driver.right.press(), driver.down.press(), driver.left.press());		Robot.autoAimState(driver.RS.press(), autoAim, driver.circle.press(), driver.cross.press(), 9);				autoAim = !driver.triangle.toggle();		realMatch = !driver.share.toggle();		if(driver.square.press()){ Robot.resetGyro(-90); }						//operator controls		Shooter.shooterState(operator.triangle.press(), operator.left.press(), operator.right.press(), autoAim);		Shooter.feederState(operator.square.hold());				Intake.intakeState(operator.cross.press(), operator.circle.hold(), driver.LB.hold());		Intake.bumperState(operator.RS.press(), driver.LT.hold());				Wobble.armState(operator.LB.press(), operator.LS.press());		Wobble.gripperState(operator.RB.press());				//match timers		/*if(mainTime.seconds() > 87 && mainTime.seconds() < 87.5 && realMatch) Wobble.newState(Wobble.ArmState.UP);		if(mainTime.seconds() > 87.5 && mainTime.seconds() < 88 && realMatch) Wobble.newState(Wobble.ArmState.FOLD);		if((realMatch && mainTime.seconds() > 121) || driver.touchpad.hold()) requestOpModeStop();*/				loopTelemetry();	}					//TELEMETRY		private void initTelemetry(){		telemetry.addData("auto aim", autoAim);		telemetry.addData("real match", realMatch);		telemetry.addData("gyro offset", gyroOffset);		telemetry.addData("start angle", offsetTelemetry);		telemetry.update();	}		private void loopTelemetry(){		telemetry.addData("time", mainTime.seconds());		telemetry.addData("auto aim", autoAim);		telemetry.addData("real match", realMatch);		telemetry.addLine();				telemetry.addLine("// DRIVE TELEMETRY //");		telemetry.addData("MEASURED angle", Sensors.gyro.modAngle());		telemetry.addData("Absolute angle", Sensors.gyro.absModAngle());		telemetry.addData("Absolute angle range", Sensors.gyro.absAngleRange(20, 160));		telemetry.addData("robtt velocity component", Sensors.robotVelocityComponent(Sensors.frontCamera.highTowerError() - 90));		telemetry.addLine();				telemetry.addLine("// SHOOTER TELEMETRY //");		telemetry.addData("target rpm", Shooter.targetRPM);		telemetry.addData("measured rpm", Shooter.getRPM());		telemetry.addData("turret angle", Shooter.getTurretAngle());		telemetry.addData("vertical component", Shooter.verticalComponent());		telemetry.addLine();				telemetry.addLine("// VISION TELEMETRY //");		telemetry.addData("tower aim error", Sensors.frontCamera.highTowerError());		telemetry.addData("distance to goal", Sensors.frontCamera.highTowerDistance());		telemetry.addData("shooter offset angle", Sensors.frontCamera.shooterOffsetAngle());		telemetry.addLine();				telemetry.addLine("// INTAKE TELEMETRY //");		telemetry.addData("target rpm", Intake.targetRPM);		telemetry.addData("measured rpm", Intake.getRPM());		telemetry.addData("power", Intake.getPower());		telemetry.update();	}}